/**
 * Attach custom color picker to toolbar
 * @param elem
 * @constructor
 */
function Color(elem) {
    let picker = new CP(elem);
    picker.self.classList.add('no-alpha');

    // Disable the default blur and focus behavior
    picker.on('blur', function () {
    });
    picker.on('focus', function () {
    });

    // Set color value and style
    picker.on('change', function (r, g, b) {
        this.source.value = this.color(r, g, b, 1);
        this.source.innerHTML = this.color(r, g, b, 1);
        this.source.style.backgroundColor = this.color(r, g, b, 1);
    });

    // Show and hide color picker panel with a click
    picker.source.addEventListener('click', function (e) {
        picker.enter();
        e.stopPropagation();
    }, false);

    document.documentElement.addEventListener('click', function () {
        picker.exit();
    }, false);

}
/**
 * Attach dropdowns to div
 * Select cancer type and slide
 */
class Dropdown {
    constructor(viewerArray, divId, dataSource) {
        // console.log('viewerArray', viewerArray);

        const cancertypes = ["blca", "brca", "cesc", "gbm", "luad", "lusc", "paad", "prad", "skcm", "ucec"];
        const maindiv = document.getElementById(divId);
        const iiif = window.location.origin + "/iiif/?iiif=/tcgaseg";
        let cancerSelect = {};
        let imageSelect = {};
        let data = {};
        initialize();

        // Speed up calls to hasOwnProperty
        let hasOwnProperty = Object.prototype.hasOwnProperty;

        function isEmpty(obj) {

            // null and undefined are "empty"
            if (obj == null) return true;

            // Assume if it has a length property with a non-zero value
            // that that property is correct.
            if (obj.length > 0) return false;
            if (obj.length === 0) return true;

            // If it isn't an object at this point
            // it is empty, but it can't be anything *but* empty
            // Is it empty?  Depends on your application.
            if (typeof obj !== "object") return true;

            // Otherwise, does it have any properties of its own?
            // Note that this doesn't handle
            // toString and valueOf enumeration bugs in IE < 9
            for (let key in obj) {
                if (hasOwnProperty.call(obj, key)) return false;
            }

            return true;
        }

        function initialize() {
            let getSlideData = async function () {
                return (await fetch(dataSource)).json();
            };
            let x = getSlideData();
            x.then(function (result) {
                data = result;
                if (!isEmpty(data)) {
                    initTypes();
                    initImages();
                }
            });
        }

        function selectCancerType() {
            let val = cancerSelect.value;
            imageSelect.options.length = 0;
            let nl = data[val];
            for (let i = 0; i < nl.length; i++) {
                let option = document.createElement("option");
                option.text = nl[i].id;
                imageSelect.add(option);
            }
            console.log("You selected: " + val + " which has " + imageSelect.options.length + " images");
            selectImage();
        }

        function imageExists(image_url) {

            let http = new XMLHttpRequest();
            http.open('HEAD', image_url, false);
            http.send();
            return http.status !== 404;

        }

        function selectImage() {
            let cVal = cancerSelect.value;
            let iVal = imageSelect.value;
            console.log("setting viewer to image : " + iVal);
            let ti = iiif + "/tcgaimages/" + cVal + "/" + iVal + ".svs/info.json";
            let si = iiif + "/featureimages/" + cVal + "/" + iVal + "-featureimage.tif/info.json";

            if (imageExists(ti)) {
                // Do something now that you know the image exists.
                viewerArray.forEach(function (elem) {
                    elem.getViewer().open([ti, si]);
                });
            } else {
                // Image doesn't exist - do something else.
                alert('Image does not exist\n' + ti);
                return false;
            }

        }

        function initTypes() {
            let d = document.createDocumentFragment();
            let newDiv = document.createElement("div");
            newDiv.innerHTML = "Type&nbsp;";
            d.appendChild(newDiv);
            cancerSelect = document.createElement('select');
            cancerSelect.id = "cancertype";
            cancertypes.forEach(function (item) {
                let opt = document.createElement('option');
                opt.innerHTML = item;
                opt.value = item;
                cancerSelect.appendChild(opt);
            });
            cancerSelect.addEventListener("change", selectCancerType);
            newDiv.appendChild(cancerSelect);
            maindiv.appendChild(d);
        }

        function initImages() {

            let images = data[cancertypes[0]];
            if (typeof images !== 'undefined') {
                let d = document.createDocumentFragment();
                let newDiv = document.createElement("div");
                newDiv.innerHTML = "Image&nbsp;";
                d.appendChild(newDiv);
                imageSelect = document.createElement("select");
                imageSelect.id = "imageids";

                images.forEach(function (item) {
                    let opt = document.createElement('option');
                    opt.innerHTML = item.id;
                    opt.value = item.id;
                    imageSelect.appendChild(opt);
                });
                imageSelect.addEventListener("change", selectImage);
                newDiv.appendChild(imageSelect);
                maindiv.appendChild(d);
            }
        }
    }
}
count = 0;
viewers = [];
let pageSetup = function () {

    let num_divs, options, prod;

    this.setup = function (num_divs1, prod1, options1) {
        num_divs = num_divs1;
        prod = prod1;

        if (isRealValue(options1)) {
            options = options1;
        } else {
            // default
            options = {
                filterOn: true,
                slidersOn: true,
                toolbarOn: true,
                multipleOn: true,
                paintbrushColor: "#0ff",
                viewerOpts: {
                    showFullPageControl: false,
                    showHomeControl: true,
                    showZoomControl: false
                }
            }

            // default if single viewer
            if (num_divs === 1) {
                options = {
                    filterOn: true,
                    slidersOn: true,
                    toolbarOn: false,
                    multipleOn: false,
                    paintbrushColor: "#0ff",
                    viewerOpts: {
                        showFullPageControl: false,
                        showHomeControl: true,
                        showZoomControl: false
                    }
                }
            }
        }

        new Promise(function (resolve, reject) {

            // Create divs
            for (let idx = 1; idx <= num_divs; idx++) {
                createDivs(idx, options);
            }
            return resolve(this.viewers);

        }).then(function (viewers) {

            // Viewers created; add dropdown to page
            new Dropdown(viewers, 'selections', './json/tcga.json');
            return viewers

        }).then(function (viewers) {

            // Pan zoom controller
            new Synchronizer(viewers);  // Pass array of nViewers
            return viewers;

        }).then(function (viewers) {

            function test() {
                // TESTING
                let dzi = "//openseadragon.github.io/example-images/duomo/duomo.dzi";
                viewers.forEach(function (elem) {
                    elem.getViewer().open(dzi)
                });
            }

            function live() {
                // Set viewer source
                const iiif = window.location.origin + "/iiif/?iiif=/tcgaseg";
                const id = "blca/TCGA-2F-A9KO-01Z-00-DX1.195576CF-B739-4BD9-B15B-4A70AE287D3E";
                viewers.forEach(function (elem) {
                    elem.setSources([iiif + "/tcgaimages/" + id + ".svs/info.json",
                    iiif + "/featureimages/" + id + "-featureimage.tif/info.json"],
                        [1.0, 1.0]);
                });
            }

            if (prod) {
                live();
            } else {
                test();
            }

        });
    }
}


let createDivs = function (idx, options) {
    let name;

    let container = document.createElement('div');
    container.className = 'divSquare';
    // container.innerHTML = 'container';
    document.body.appendChild(container);


    name = 'controls';
    let controlsDiv = document.createElement("div"); // 'controls' div
    controlsDiv.id = name;
    controlsDiv.className = name;
    // controlsDiv.innerHTML = name;

    container.appendChild(controlsDiv); // add to 'container' div


    name = 'range';
    let rangeDiv = document.createElement("div"); // div containing 'sliders'
    // rangeDiv.innerHTML = name;
    rangeDiv.className = name;
    controlsDiv.append(rangeDiv);

    // 2 sliders
    let sliders;
    if (options.slidersOn) {
        sliders = createSliders(idx, rangeDiv, 2, options);
    }


    if (options.toolbarOn) {
        let buttonDiv = document.createElement("div"); // div containing 'buttons'
        buttonDiv.classList.add('floated');
        buttonDiv.classList.add('buttons');
        controlsDiv.append(buttonDiv);

        // Create buttons
        createButtons(idx, buttonDiv, options);

        // Color picker event handler
        new Color(document.getElementById('mark' + idx));
    }

    // Slider button event handler
    if (options.slidersOn && options.toolbarOn) {
        sliderBtnEvt(idx, sliders);
    }


    name = 'viewer';
    let viewerDiv = document.createElement("div"); // 'viewer' div
    viewerDiv.id = name + idx;
    viewerDiv.className = name;
    // viewerDiv.innerHTML = name;

    container.appendChild(viewerDiv);


    this.viewers.push(new nViewer("viewer" + idx, sliders, options));


    // Clear:both between rows
    if (idx % 2 === 0) {
        let div = document.createElement('div');
        div.style.clear = 'both';
        document.body.appendChild(div);
    }

}


let createButtons = function (idx, div, options) {
    let color;
    if (isRealValue(options.paintbrushColor)) {
        color = options.paintbrushColor;
    } else {
        color = "#00f";
    }

    let htm = `<input type="checkbox" id="chkPan${idx}" checked=""><label for="chkPan${idx}">Match Pan</label>&nbsp;
    <input type="checkbox" id="chkZoom${idx}" checked=""><label for="chkZoom${idx}">Match Zoom</label>&nbsp;`;

    if (!options.multipleOn) {
        htm = '';
    }
    div.innerHTML = htm + `<input type="checkbox" id="chkPan${idx}" checked=""><label for="chkPan${idx}">Match Pan</label>&nbsp;
    <input type="checkbox" id="chkZoom${idx}" checked=""><label for="chkZoom${idx}">Match Zoom</label>&nbsp;
        <mark id="mark${idx}">${color}</mark>&nbsp;
        <button id="btnDraw${idx}" class="btn"><i class="fa fa-pencil-alt"></i> Draw polygon</button>&nbsp;
        <button id="btnEdit${idx}" class="btn"><i class="fa fa-draw-polygon"></i> Edit polygon</button>&nbsp;
        <button id="btnGrid${idx}" class="btn"><i class="fa fa-border-all"></i> Draw grid</button>&nbsp;
        <button id="btnMarker${idx}" class="btn"><i class="fa fa-paint-brush"></i> Mark grid</button>&nbsp;
        <button id="btnSlide${idx}" class="btn"><i class="fa fa-sliders"></i> Show sliders</button>&nbsp;
        <button id="toggle-overlay" class="btn" style="display: none"><i class="fa fa-map-marker-alt"></i> Hide markers</button>
    </a>`;

}


let createSliders = function (idx, div, num, options) {
    let sliders = [];
    let d = document.createDocumentFragment();

    for (let i = 0; i < num; i++) {

        let range = document.createElement('input');
        range.type = "range";
        this.count += 1;
        range.id = "sliderRange" + this.count;
        range.min = "0";
        range.max = "100";
        range.value = "100";
        range.setAttribute('class', "slider-square");
        if (options.toolbarOn) {
            range.style.display = 'none';
        } else {
            range.style.display = 'inline'; // bc we have a btn to toggle it
        }

        d.appendChild(range); // append div to fragment
        div.appendChild(d); // append fragment to parent
        sliders.push(range);
    }
    return sliders;
}


let sliderBtnEvt = function (idx, sliders) {

    // Slider button event handler
    let btnSlide = document.getElementById("btnSlide" + idx);
    if (isRealValue(btnSlide)) {
        btnSlide.addEventListener('click', function () {

            // (2) sliders.
            if (sliders[0].style.display === 'none') { // no need to check both; just the one.

                // Show the sliders
                sliders[0].style.display = 'inline';
                sliders[1].style.display = 'inline';

                // Style the button
                this.innerHTML = "<i class=\"fa fa-sliders\"></i> Hide sliders";

            } else {
                // Hide the sliders
                sliders[0].style.display = 'none';
                sliders[1].style.display = 'none';

                // Style the button
                this.innerHTML = "<i class=\"fa fa-sliders\"></i> Show sliders";
            }
            toggleBtn(btnSlide);
        });
    } else {
        console.log('slide is null');
    }

    function toggleBtn(btn) {
        let isOn = btn.classList.contains('btnOn');
        let classList = btn.classList;
        while (classList.length > 0) {
            classList.remove(classList.item(0));
        }
        if (isOn) {
            btn.classList.add('btn');
        } else {
            btn.classList.add('btnOn');
        }
    }

}
pathToPoly = function (fabPath, canvas, paintBrush) {

    const _points0 = fabPath.path.map(item => ({
        x: item[1],
        y: item[2]
    }));

    // THERE ARE WAY TOO MANY POINTS; REDUCE THEM:
    let points = _points0.reduce(
        function (accumulator, currentValue, currentIndex) {
            if (currentIndex % 7 === 0)
                accumulator.push(currentValue);
            return accumulator;
        }, []);

    // CREATE NEW OBJECT
    let poly = new fabric.Polygon(points, {
        left: fabPath.left,
        top: fabPath.top,
        fill: "",
        strokeWidth: paintBrush.width,
        stroke: paintBrush.color,
        scaleX: fabPath.scaleX,
        scaleY: fabPath.scaleY,
        objectCaching: false,
        transparentCorners: false,
        cornerColor: "blue"
    });
    canvas.add(poly);
    canvas.setActiveObject(poly);
    canvas.remove(fabPath);
}

// CONTROL HANDLING FUNCTIONS

// Locate the controls.
function polygonPositionHandler(dim, finalMatrix, fabricObject) {
    // Do for all points
    let x = fabricObject.points[this.pointIndex].x - fabricObject.pathOffset.x,
        y = fabricObject.points[this.pointIndex].y - fabricObject.pathOffset.y;
    return fabric.util.transformPoint(
        { x: x, y: y },
        fabric.util.multiplyTransformMatrices(
            fabricObject.canvas.viewportTransform,
            fabricObject.calcTransformMatrix()
        )
    );
}

// This function will be called on every mouse move after a control has been
// clicked and is being dragged.
function actionHandler(eventData, transform, x, y) {
    // polygon.__corner is the handle that you dragged.
    let polygon = transform.target,
        currentControl = polygon.controls[polygon.__corner],
        mouseLocalPosition = polygon.toLocalPoint(
            new fabric.Point(x, y),
            "center",
            "center"
        ),
        polygonBaseSize = polygon._getNonTransformedDimensions(),
        size = polygon._getTransformedDimensions(0, 0),
        finalPointPosition = {
            x:
                (mouseLocalPosition.x * polygonBaseSize.x) / size.x +
                polygon.pathOffset.x,
            y:
                (mouseLocalPosition.y * polygonBaseSize.y) / size.y +
                polygon.pathOffset.y
        };
    polygon.points[currentControl.pointIndex] = finalPointPosition;
    return true;
}

// Keep the polygon in the same position when we change its
// width/height/top/left.
function anchorWrapper(anchorIndex, fn) {
    // Once per button click when edit = yes.
    return function (eventData, transform, x, y) {
        let fabricObject = transform.target,
            absolutePoint = fabric.util.transformPoint(
                {
                    x: fabricObject.points[anchorIndex].x - fabricObject.pathOffset.x,
                    y: fabricObject.points[anchorIndex].y - fabricObject.pathOffset.y
                },
                fabricObject.calcTransformMatrix()
            ),
            actionPerformed = fn(eventData, transform, x, y),
            polygonBaseSize = fabricObject._getNonTransformedDimensions(),
            newX =
                (fabricObject.points[anchorIndex].x - fabricObject.pathOffset.x) /
                polygonBaseSize.x,
            newY =
                (fabricObject.points[anchorIndex].y - fabricObject.pathOffset.y) /
                polygonBaseSize.y;
        fabricObject.setPositionByOrigin(absolutePoint, newX + 0.5, newY + 0.5);
        return actionPerformed;
    };
}

function getPolygon(canvas) {
    if (canvas.getActiveObject()) {
        return canvas.getActiveObject();
    } else {
        if (canvas.getObjects()[0] && canvas.getObjects()[0].type === 'polygon') {
            return canvas.getObjects()[0];
        }
    }
}

function isRealValue(obj) {
    return obj && obj !== 'null' && obj !== 'undefined';
}

function Edit(canvas) {

    let poly = getPolygon(canvas);

    if (isRealValue(poly)) {
        // console.log("instance of Polygon:", poly instanceof fabric.Polygon);
        canvas.setActiveObject(poly);
        poly.edit = !poly.edit;
        if (poly.edit) {
            let lastControl = poly.points.length - 1;
            poly.cornerStyle = 'circle';
            poly.cornerColor = 'rgba(0,0,255,0.5)';

            // accumulator, next item, index
            let reduceFun = function (acc, point, index) {
                // Create a control object for each polygon point
                acc['p' + index] = new fabric.Control({
                    positionHandler: polygonPositionHandler,
                    actionHandler: anchorWrapper(index > 0 ? index - 1 : lastControl, actionHandler),
                    actionName: 'modifyPolygon',
                    pointIndex: index
                });
                return acc;
            }

            // Create a control buddy [hashtable]. Point p0 = corresponding Control object.
            // function, initial value
            poly.controls = poly.points.reduce(reduceFun, {});

        } else {
            poly.cornerColor = 'blue';
            poly.cornerStyle = 'rect';
            // Default controls:
            poly.controls = fabric.Object.prototype.controls;
        }
        poly.hasBorders = !poly.edit;
        canvas.requestRenderAll();
    } else {
        alert('Please select a polygon for editing.');
    }
}
/**
 * Handler for right-click, add map marker.
 * @param currentViewer
 * @param syncedViewers
 */
locationPin = function (currentViewer, syncedViewers) {

    // const idx = currentViewer.id.trim(-1).replace("viewer", "");

    // prevent modal
    // $(currentViewer.element).on('contextmenu', (event) => {
    //     event.preventDefault();
    // });

    // right-click
    currentViewer.addHandler('canvas-nonprimary-press', (event) => {
        if (event.button === 2) { // Right mouse
            const webPoint = event.position;
            const viewportPoint = currentViewer.viewport.pointFromPixel(webPoint);
            // document.getElementById("btnMap" + idx).style.display = 'block';
            document.querySelectorAll('#toggle-overlay').forEach(function (item) {
                item.style.display = 'block';
            });
            displayPinIcon(viewportPoint);
        }
    });

    function createLink() {
        // let rand = Math.floor(Math.random() * 11);
        let link = document.createElement('a');
        let href = "#";
        link.href = href;
        link.dataset.href = href;
        link.id = 'map-marker';
        // link.id = 'map-marker-' + rand;
        link.className = 'fa fa-map-marker';
        link.style.cssText =
            ' text-decoration: none; font-size: 22px; color: red;' +
            ' cursor: pointer';
        return link;
    }

    function doOverlay(point, viewer) {
        // console.log('v', viewer.overlaysContainer.children);
        let link = createLink();
        viewer.addOverlay({
            element: link,
            location: point,
            placement: 'BOTTOM',
            checkResize: false
        });
        mouseTracker(link, viewer);
        // viewer.removeOverlay()

    }

    // display map marker
    function displayPinIcon(point) {
        const all = true; // temporarily
        if (all) {
            // Show on all other viewers
            syncedViewers.forEach(function (item) {
                let viewer = item.getViewer()
                if (viewer.id === currentViewer.id) {
                    return;
                }
                doOverlay(point, viewer);
            });
        } else {
            // Show only on this viewer
            doOverlay(point, currentViewer)
        }
    }

    function mouseTracker(link, viewer) {
        // TBA
        new OpenSeadragon.MouseTracker({
            element: link,
            clickHandler: function () {
                console.log('clickHandler');
                // etc
            },
            dragHandler: function () {
                console.log('dragHandler');
                // etc
            }
        });
    }


    let elementList = document.querySelectorAll('#toggle-overlay');
    elementList.forEach(function (elem) {
        let overlay = false;
        let s, h;
        elem.addEventListener('click', function () {
            if (overlay) {
                s = 'block';
                h = "<i class=\"fa fa-map-marker\"></i> Hide markers";
            } else {
                s = 'none';
                h = "<i class=\"fa fa-map-marker\"></i> Show markers";
            }
            this.innerHTML = h;
            document.querySelectorAll('#map-marker').forEach(function (thing) {
                thing.style.display = s;
            })
            overlay = !overlay;
        })
    });

}
function markupTools(idx, viewer) {

    const overlay = viewer.fabricjsOverlay({
        scale: 1000
    });
    const canvas = overlay.fabricCanvas();

    const btnGrid = document.getElementById('btnGrid' + idx);
    const btnDraw = document.getElementById('btnDraw' + idx);

    function clearClassList(element) {
        let classList = element.classList;
        while (classList.length > 0) {
            classList.remove(classList.item(0));
        }
    }

    function toggleButton(btn) {
        let isOn = btn.classList.contains('btnOn');
        clearClassList(btn);
        if (isOn) {
            btn.classList.add('btn');
        } else {
            btn.classList.add('btnOn');
        }
    }

    /**
     * GRID handler
     */

    let cellX = [], cellY = [], cell_size = 50, gridAdded = false, dim_width, dim_height;

    function renderGrid(width, height, cell_width, cell_height, color) {
        console.log(width, height, cell_width, cell_height, color)

        let lineOption = { stroke: color, strokeWidth: 2, selectable: false }

        // Horizontal grid lines
        for (let y = 0; y < Math.ceil(height / cell_height); ++y) {
            canvas.add(new fabric.Line([0, y * cell_height, width, y * cell_height], lineOption));
            cellY[y + 1] = y * cell_height;
        }

        // Vertical grid lines
        for (let x = 0; x < Math.ceil(width / cell_width); ++x) {
            canvas.add(new fabric.Line([x * cell_width, 0, x * cell_width, height], lineOption));
            // cellX[x + 1] = x * cell_width;
            cellX[x] = x * cell_width;
        }
        canvas.renderAll();
        gridAdded = true;

    }

    // Grid button event handler
    btnGrid.addEventListener('click', function () {

        let dimWidthEl = document.getElementById("dim-w");
        let dimHeightEl = document.getElementById("dim-h");

        if (isRealValue(dimWidthEl) && isRealValue(dimHeightEl)) {
            dim_width = Math.ceil(dimWidthEl.value);
            dim_height = Math.ceil(dimHeightEl.value);

            if (btnGrid.classList.contains('btnOn')) {
                // Remove only the lines
                let r = canvas.getObjects('line');
                for (let i = 0; i < r.length; i++) {
                    canvas.remove(r[i]);
                }
                btnGrid.innerHTML = '<i class="fa fa-border-all"></i> Draw grid';
                gridAdded = false;

            } else {

                // DRAW GRID
                renderGrid(dim_width, dim_height, cell_size, cell_size, 'red');
                btnGrid.innerHTML = '<i class="fa fa-border-all"></i> Remove grid';
                gridAdded = true;
            }
        }
        toggleButton(btnGrid);

    });


    // Grid Marker
    let btnMarker = document.getElementById('btnMarker' + idx);
    btnMarker.addEventListener('click', markerHandler);

    // Get coordinates of mouse pointer
    function mouseCoords(options) {
        let event = options.e;
        let rect = document.getElementById('viewer' + idx).getBoundingClientRect();
        const mouseCoords = { x: event.clientX - rect.left, y: event.clientY - rect.top }

        let cx = mouseCoords.x;
        let cy = mouseCoords.y;

        let x = cx / cell_size;
        let y = cy / cell_size;
        let imoX = Math.ceil(x + 0.001); // IsMouseOverX (mouse(block) position on grid)
        let imoY = Math.ceil(y + 0.001); // IsMouseOverY (mouse(block) position on grid)

        let ctx = viewer.drawer.context;
        ctx.fillStyle = "red";
        ctx.fillRect(cellX[imoX], cellY[imoY], cell_size, cell_size);
    }

    // Grid marker event handler
    function markerHandler() {
        let toggle = true;
        if (btnMarker.classList.contains('btnOn')) {
            // Remove mouse:move listener (we also use it for other things)
            canvas.off("mouse:move", mouseCoords);
            btnMarker.innerHTML = "<i class=\"fa fa-paint-brush\"></i> Mark grid";

        } else {
            if (!gridAdded) {
                toggle = false;
                alert("Please draw a grid first.");
            } else {
                // Add listener
                canvas.on("mouse:move", mouseCoords);
                btnMarker.innerHTML = "<i class=\"fa fa-paint-brush\"></i> Done marking";
            }
        }
        if (toggle) {
            toggleButton(btnMarker);
        }
    }

    // EDIT POLYGON
    document.getElementById('btnEdit' + idx).addEventListener('click', function () {
        toggleButton(this);
        Edit(canvas);
    });

    /**
     * FreeDrawing handler
     */
    const paintBrush = overlay.fabricCanvas().freeDrawingBrush;
    const mark = document.getElementById('mark' + idx);
    paintBrush.color = mark.innerHTML;

    function addDeleteBtn(x, y, el) {
        $(".deleteBtn").remove();
        let btnLeft = x - 10;
        let btnTop = y - 10;
        let deleteBtn = document.createElement('img');
        deleteBtn.src = "./img/delete-icon.png";
        deleteBtn.classList.add('deleteBtn')
        deleteBtn.style = `position:absolute;top:${btnTop};left:${btnLeft};cursor:pointer;width:20px;height:20px;`;
        deleteBtn.alt = "delete object";
        el.appendChild(deleteBtn);
    }

    function f(e, c) {
        let el = c.lowerCanvasEl.parentElement;
        if (isRealValue(e.target.oCoords.tr) && isRealValue(el)) {
            addDeleteBtn(e.target.oCoords.tr.x, e.target.oCoords.tr.y, el);
        }
    }

    function customizeControls(obj) {
        // For the object that was drawn
        obj['hasControls'] = false;
        obj.lockMovementX = true; // hold in place
        obj.lockMovementY = true;

        canvas.on('selection:created', function (e) {
            f(e, canvas);
        })

        // It's not movable/scalable/etc now, but it might be one day.
        canvas.on('object:modified', function (e) {
            f(e, canvas);
        });

        canvas.on('object:scaling', function (e) {
            $(".deleteBtn").remove();
            f(e, canvas);
        });

        canvas.on('object:moving', function (e) {
            $(".deleteBtn").remove();
            f(e, canvas);
        });

        canvas.on('object:rotating', function (e) {
            $(".deleteBtn").remove();
            f(e, canvas);
        });

        $(".canvas-container").on('click', ".deleteBtn", function () {
            viewer.gestureSettingsMouse.clickToZoom = false;
            // this = deleteBtn
            if (canvas.getActiveObject()) {
                canvas.remove(canvas.getActiveObject());
                $(".deleteBtn").remove();
            }
            // Delete finished; re-enable zoom.
            viewer.gestureSettingsMouse.clickToZoom = true;
        });

    }

    function setBrushWidth(viewer) {
        paintBrush.width = 10 / viewer.viewport.getZoom(true);
    }

    function mToggle(what) {
        viewer.setMouseNavEnabled(what);
        viewer.outerTracker.setTracking(what);
    }

    // todo: fix. it makes 2 on 2nd make line.
    //function pathToPoly(fabPath) {

    // DRAW BUTTON
    btnDraw.addEventListener('click', function () {
        toggleButton(btnDraw);
        canvas.on("mouse:up", mouseupHandler);
        canvas.on("path:created", pathCreatedHandler);

        function pathCreatedHandler(options) {
            // options gives you the Path object
            // todo: get this to stop doing it for all objects.
            let fabPath = options.path;
            pathToPoly(fabPath, canvas, paintBrush);
            customizeControls(fabPath);
            clearClassList(btnDraw);
            btnDraw.classList.add('btn');
            // canvas.off('mouse:down', mousedownHandler);
            // canvas.off("mouse:up", mouseupHandler);
            // TODO: implement save
            // console.log('PATH:\n', path);
        }

        function mouseupHandler(options) {
            // options gives you the PointerEvent object
            // Drawing off
            canvas.isDrawingMode = false;
            mToggle(true);
        }

        function mousedownHandler() {
            // For example, panning or zooming after selection
            if (!canvas.getActiveObject()) {
                $(".deleteBtn").remove();
                viewer.gestureSettingsMouse.clickToZoom = true;
            } else {
                // Prevent zoom on delete.
                viewer.gestureSettingsMouse.clickToZoom = false;
            }
        }

        if (canvas.isDrawingMode) {
            // drawing off
            canvas.isDrawingMode = false;
            canvas.off('mouse:down', mousedownHandler);
            mToggle(true);

        } else {
            // drawing on
            canvas.isDrawingMode = true;
            canvas.on('mouse:down', mousedownHandler);
            paintBrush.color = mark.innerHTML;
            setBrushWidth(viewer);
            mToggle(false);

        }
    });
}
/**
 * Wrapper object for the osd viewers
 */
class nViewer {
    constructor(viewerDivId, sliders, options) {
        // console.log(viewerDivId, sliders, options);

        let idx = viewerDivId.replace("viewer", "");
        let myFilter = {};
        let viewer = {};

        // Checkboxes
        let chkPan = {};
        let chkZoom = {};
        if (options.multipleOn) {
            chkPan = document.getElementById("chkPan" + idx);
            chkZoom = document.getElementById("chkZoom" + idx);
        }

        setFilter();
        setViewer(viewerDivId);

        this.getViewer = function () {
            return viewer;
        };

        this.getChkPan = function () {
            return chkPan.checked;
        };

        this.getChkZoom = function () {
            return chkZoom.checked;
        };

        viewer.addHandler('open', (param) => {
            let dimWidthEl = document.getElementById("dim-w");
            let dimHeightEl = document.getElementById("dim-h");
            let tiledImage = viewer.world.getItemAt(0);
            let imgRect = tiledImage.getBounds(true);
            let elementRect = viewer.viewport.viewportToViewerElementRectangle(
              imgRect
            );
            dimWidthEl.value = elementRect.width;
            dimHeightEl.value = elementRect.height;

        })

        /**
         * @param imageArray
         * @param opacityArray
         */
        this.setSources = function (imageArray, opacityArray) {

            imageArray.forEach(function (image, index) {
                // add images to viewer
                viewer.addTiledImage({ tileSource: image, opacity: opacityArray ? opacityArray[index] : 0, x: 0, y: 0 });
            });

            viewer.world.addHandler("add-item", (event) => {

                if (viewer.world.getItemCount() === 2) {
                    // colorize layer 2
                    viewer.setFilterOptions({
                        filters: [{
                            items: viewer.world.getItemAt(1),
                            processors: [
                                myFilter.prototype.COLORIZE(0, 255, 0)
                            ]
                        }]
                    });

                    viewer.world.getItemAt(1).source.getTileUrl = function (level, x, y) {
                        let IIIF_ROTATION = '0', scale = Math.pow(0.5, this.maxLevel - level),
                            levelWidth = Math.ceil(this.width * scale), levelHeight = Math.ceil(this.height * scale), tileSize,
                            iiifTileSize, iiifTileSizeWidth, iiifTileSizeHeight, iiifRegion, iiifTileX, iiifTileY, iiifTileW,
                            iiifTileH, iiifSize, iiifQuality, uri;
                        tileSize = this.getTileWidth(level);
                        iiifTileSize = Math.ceil(tileSize / scale);
                        iiifTileSizeHeight = iiifTileSize;
                        iiifTileSizeWidth = iiifTileSize;
                        iiifQuality = "default.png";
                        if (levelWidth < tileSize && levelHeight < tileSize) {
                            iiifSize = levelWidth + ",";
                            iiifRegion = 'full';
                        } else {
                            iiifTileX = x * iiifTileSizeWidth;
                            iiifTileY = y * iiifTileSizeHeight;
                            iiifTileW = Math.min(iiifTileSizeWidth, this.width - iiifTileX);
                            iiifTileH = Math.min(iiifTileSizeHeight, this.height - iiifTileY);
                            iiifSize = Math.ceil(iiifTileW * scale) + ",";
                            iiifRegion = [iiifTileX, iiifTileY, iiifTileW, iiifTileH].join(',');
                        }
                        uri = [this['@id'], iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality].join('/');
                        return uri;
                    };
                }

            });

        };

        /**
         * INITIALIZE
         */
        function setViewer(viewerDivId) {
            console.log(viewerDivId);

            viewer = OpenSeadragon({
                id: viewerDivId,
                prefixUrl: "./js/lib/openseadragon/images/",
                showFullPageControl: options.viewerOpts.showFullPageControl,
                showHomeControl: options.viewerOpts.showHomeControl,
                showZoomControl: options.viewerOpts.showZoomControl,
                crossOriginPolicy: 'Anonymous'
            });

            // Markup tools event listeners
            if (options.toolbarOn) {
                markupTools(idx, viewer);
            }

            // Sliders event listeners
            if (options.slidersOn) {

                for (let i = 0; i < sliders.length; i++) {

                    sliders[i].addEventListener("input", function () {
                        console.log('adfsa', viewer.world.getItemAt(i))
                        if (viewer.world.getItemAt(i) !== undefined) {
                            viewer.world.getItemAt(i).setOpacity(sliders[i].value / 100);
                        } else {
                            sliders[i].hidden = true;
                        }
                    });
                }
            }

            // Filtering
            if (options.filterOn) {

                viewer.setFilterOptions({
                    filters: [{
                        items: viewer.world.getItemAt(1),
                        processors: [
                            myFilter.prototype.COLORIZE(0, 255, 0)
                        ]
                    }]
                });
            }
        }

        function setFilter() {
            myFilter = OpenSeadragon.Filters.GREYSCALE;
            myFilter.prototype.COLORIZE = function (r, g, b) {
                return function (context, callback) {
                    let imgData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
                    let pixels = imgData.data;
                    for (let i = 0; i < pixels.length; i += 4) {
                        let avg = pixels[i] / 255;
                        if (pixels[i + 3] === 255) {
                            pixels[i] = r * avg;
                            pixels[i + 1] = g * avg;
                            pixels[i + 2] = b * avg;
                            pixels[i + 3] = avg * 255;
                        } else if (pixels[i] > 0) {
                            pixels[i + 3] = 0;
                        }
                    }
                    context.putImageData(imgData, 0, 0);
                    callback();
                };
            };
        }
    }
}
/**
 * Handles synchronization of the viewers
 */
class Synchronizer {
    constructor(viewerArray) {
        // console.log('viewerArray', viewerArray);

        // let len = viewerArray.length;
        // viewerArray.forEach(element => element.modOptions(len));

        let syncedViewers = []; // array of synchronized viewers
        let activeViewerId = null; // magic init

        // Loop through array of n-viewers
        viewerArray.forEach(function (elem) {
            // Created viewer already.
            let currentViewer = elem.getViewer();

            // Add handlers
            currentViewer.addHandler('pan', handler);
            currentViewer.addHandler('zoom', handler);
            locationPin(currentViewer, syncedViewers);

            function handler(event) {
                // My viewer is clicked, I'm the active viewer
                // start magic
                if (activeViewerId == null) {
                    activeViewerId = currentViewer.id;
                }
                if (activeViewerId !== currentViewer.id) {
                    return;
                }
                // end magic

                // As for everybody else...
                syncedViewers.forEach(function (item) {
                    let view = item.getViewer()
                    if (view.id === currentViewer.id) {
                        return;
                    }

                    // other viewers' coords set to my coordinates
                    // EXCEPT...
                    if (item.getChkPan() && elem.getChkPan()) {
                        view.viewport.panTo(currentViewer.viewport.getCenter());
                    }
                    if (item.getChkZoom() && elem.getChkZoom()) {
                        view.viewport.zoomTo(currentViewer.viewport.getZoom());
                    }

                });
                // magic support
                activeViewerId = null;
            }

            syncedViewers.push(elem);  // add our [viewer] to our list
        });
    }
}
